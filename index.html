// index.h
// This file contains the HTML content for the web page.
// It is stored in a separate header file to avoid parsing issues with R"rawliteral" strings
// that can cause compilation errors in some Arduino/ESP32 toolchains.

const char PROGMEM INDEX_HTML[] = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<title>ESP32 Live Temperature Graph</title>
<script src="https://cdn.jsdelivr.net/npm/dygraphs@2.1.0/dist/dygraph.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dygraphs@2.1.0/dist/dygraph.css" />
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #e0e0e0; /* Grey background */
    margin: 0; /* Remove default margin */
    padding: 20px; /* Add some padding around content */
    display: flex; /* Use flexbox for centering */
    flex-direction: column; /* Arrange items vertically */
    align-items: center; /* Center horizontally */
    min-height: 100vh; /* Ensure body takes full viewport height */
  }
  h1 {
    color: #000066; /* Dark blue color from screenshot */
    font-size: 2.5em; /* Adjust font size to match screenshot */
    margin-bottom: 5px; /* Reduce space below h1 */
  }
  /* Removed #status */
  #totalTimePassed, #liveTempDisplay { /* Changed from #uptime to #totalTimePassed */
    color: #555555;
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.1em;
  }
  #totalTimePassed { /* Changed from #uptime */
      margin-bottom: 20px; /* Space between header and live temp display */
      font-size: 1.2em;
  }

  /* This will be the container for the graph, to give it the black border and white background */
  #chartContainer {
    width: 90%;
    max-width: 800px; /* Max width for graph area */
    margin: 20px auto; /* Center the container and add vertical space */
    background-color: white; /* White background for the graph area */
    padding: 15px; /* Padding inside the box */
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    border: 2px solid black; /* Black border for division */
    box-sizing: border-box; /* Include padding and border in the element's total width and height */
  }

  /* The actual dygraph div needs a height */
  #graphdiv {
    width: 100%; /* Take full width of its container */
    height: 400px; /* Set a fixed height for the graph */
  }

  /* Force subscript rendering within Dygraph legend (may still be needed for other reasons) */
  .dygraph-legend sub {
    vertical-align: sub;
    font-size: smaller;
  }
</style>
</head>
<body>

<h1>Mobile Thermoelectric pRBC Refrigeration System</h1>
<p id="totalTimePassed">Total Time: --:--:--</p> <p id="liveTempDisplay">Fetching data...</p>


<div id="chartContainer">
    <div id="graphdiv"></div>
</div>

<script>
  let dygraphChart;
  let dygraphData = [];
  // 3 hours * 60 minutes/hour * 60 seconds/minute = 10800 seconds/points
  const max_data_points = 10800;

  const liveTempDisplay = document.getElementById('liveTempDisplay');
  const totalTimePassedDisplay = document.getElementById('totalTimePassed');

  // IMPORTANT: This should be the SAME URL as in your ESP32 code (aaa.ino)
  const GOOGLE_SHEETS_SCRIPT_URL_JS = "https://script.google.com/macros/s/AKfycbxf_eCOGxhebT9VcirPCecN-gkxNBucyKSCS5ItNtDRPHVxd9Xes06eTSMkP21oAtNd8Q/exec";

  // Interval for polling Google Sheets for updates (1 second)
  const pollingInterval = 1000; // Poll every 1 second

  let firstDataSecondsCounter = 0; // To store the seconds_counter of the very first data point for total time calculation

  function updateTotalTimePassedDisplay() {
      if (firstDataSecondsCounter === 0) {
          totalTimePassedDisplay.textContent = 'Total Time: --:--:-- (Waiting for data...)';
          return;
      }

      // Find the latest seconds_counter from the graph data
      let latestSecondsCounter = 0;
      if (dygraphData.length > 0) {
          latestSecondsCounter = dygraphData[dygraphData.length - 1][0]; // Assuming seconds_counter is the first element in each data point array
      }

      const elapsedSeconds = latestSecondsCounter - firstDataSecondsCounter;

      const hours = Math.floor(elapsedSeconds / 3600);
      const minutes = Math.floor((elapsedSeconds % 3600) / 60);
      const seconds = Math.floor(elapsedSeconds % 60);

      const formatTime = (num) => num < 10 ? '0' + num : num;
      totalTimePassedDisplay.textContent = `Total Time: ${formatNum(hours)}:${formatNum(minutes)}:${formatNum(seconds)}`;
  }

  // Update total time passed every second
  setInterval(updateTotalTimePassedDisplay, 1000);

  // Function to fetch ALL data from Google Sheets (both history and latest for live display)
  async function fetchAllDataFromSheets() {
      console.log("Fetching all data from Google Sheets...");
      liveTempDisplay.textContent = 'Fetching data...'; // Indicate data loading

      try {
          const response = await fetch(`${GOOGLE_SHEETS_SCRIPT_URL_JS}?action=read_history`);
          if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
          }
          const allSensorData = await response.json();
          console.log("All data received:", allSensorData);

          dygraphData = []; // Reset the data array each time for a fresh view from the sheet
          if (allSensorData.length > 0) {
              // Set the first seconds_counter if not already set (for total time display)
              if (firstDataSecondsCounter === 0) {
                  firstDataSecondsCounter = allSensorData[0].seconds_counter;
                  console.log("Initial data collection seconds_counter set to:", firstDataSecondsCounter);
              }

              allSensorData.forEach(point => {
                  // Use seconds_counter for X-axis (time)
                  dygraphData.push([
                      point.seconds_counter, // X-axis data
                      point.T_pRBC,
                      point.T_enc,
                      point.T_env,
                      point.T_TEC
                  ]);
              });

              // Trim data to max_data_points if history is too long
              if (dygraphData.length > max_data_points) {
                  dygraphData = dygraphData.slice(dygraphData.length - max_data_points);
              }

              // Get the latest data point for the live display
              const latestData = allSensorData[allSensorData.length - 1]; // Last element is the most recent
              liveTempDisplay.innerHTML = `Live Temperatures Plotting:
                  T<sub>pRBC</sub> = ${latestData.T_pRBC !== undefined ? latestData.T_pRBC.toFixed(3) : '--.--'} &deg;C,
                  T<sub>enc</sub> = ${latestData.T_enc !== undefined ? latestData.T_enc.toFixed(3) : '--.--'} &deg;C,
                  T<sub>env</sub> = ${latestData.T_env !== undefined ? latestData.T_env.toFixed(3) : '--.--'} &deg;C,
                  T<sub>TEC</sub> = ${latestData.T_TEC !== undefined ? latestData.T_TEC.toFixed(3) : '--.--'} &deg;C`;

          } else {
              liveTempDisplay.innerHTML = `Live Temperatures Plotting: --.-- &deg;C`; // No data yet
          }

          // Initialize or update the chart
          const dygraphOptions = {
            // Updated labels for Dygraph, now X-axis is "Seconds" or "Time" based on the new column
            labels: ["Seconds", "TpRBC", "Tenc", "Tenv", "TTEC"],
            ylabel: "Temperature (&deg;C)",
            xlabel: "Time (HH:MM:SS from Start)", // Clarify X-axis label
            axes: {
              y: {
                valueRange: [-6, 32],
              },
              x: { // Define X-axis as numeric, not time series, and format its labels
                axisLabelFormatter: function(x) {
                    // Format seconds into HH:MM:SS for the X-axis labels
                    let hours = Math.floor(x / 3600);
                    let minutes = Math.floor((x % 3600) / 60);
                    let seconds = Math.floor(x % 60);
                    const formatNum = (num) => num < 10 ? '0' + num : num;
                    return `${formatNum(hours)}:${formatNum(minutes)}:${formatNum(seconds)}`;
                },
                valueFormatter: function(x) {
                    // Format seconds into HH:MM:SS for tooltips/hover
                    let hours = Math.floor(x / 3600);
                    let minutes = Math.floor((x % 3600) / 60);
                    let seconds = Math.floor(x % 60);
                    const formatNum = (num) => num < 10 ? '0' + num : num;
                    return `${formatNum(hours)}:${formatNum(minutes)}:${formatNum(seconds)}`;
                }
              }
            },
            series: {
              "TpRBC": { color: "red" },
              "Tenc":  { color: "blue" },
              "Tenv":  { color: "green" },
              "TTEC":  { color: "orange" }
            },
            animatedZooms: false,
            drawPoints: true,
            strokeWidth: 1.5,
            legend: "always",
            fillGraph: false,
            useHtmlLabels: true,
            labelsSeparateLines: false,
          };

          if (dygraphChart) {
              dygraphChart.updateOptions({ 'file': dygraphData });
          } else {
              dygraphChart = new Dygraph(
                document.getElementById("graphdiv"),
                dygraphData,
                dygraphOptions
              );
          }
          // Manual legend fix after chart update/creation
          fixLegendSubscripts();

      } catch (error) {
          console.error("Error fetching all data from Sheets:", error);
          liveTempDisplay.textContent = 'Error fetching data. Check console.';
          totalTimePassedDisplay.textContent = 'Total Time: Sync Error!';
      }
  }

  // Manual legend fix function
  function fixLegendSubscripts() {
      const legendElement = document.querySelector('.dygraph-legend');
      if (legendElement) {
          const spans = legendElement.querySelectorAll('span');
          spans.forEach(span => {
              let currentHtml = span.innerHTML;
              let newHtml = currentHtml;

              // Ensure the replacement logic is precise and avoids re-replacing
              if (currentHtml.includes("TpRBC") && !currentHtml.includes("<sub>pRBC</sub>")) {
                  newHtml = newHtml.replace("TpRBC", "T<sub>pRBC</sub>");
              }
              if (currentHtml.includes("Tenc") && !currentHtml.includes("<sub>enc</sub>")) {
                  newHtml = newHtml.replace("Tenc", "T<sub>enc</sub>");
              }
              if (currentHtml.includes("Tenv") && !currentHtml.includes("<sub>env</sub>")) {
                  newHtml = newHtml.replace("Tenv", "T<sub>env</sub>");
              }
              if (currentHtml.includes("TTEC") && !currentHtml.includes("<sub>TEC</sub>")) {
                  newHtml = newHtml.replace("TTEC", "T<sub>TEC</sub>");
              }
              if (newHtml !== currentHtml) {
                  span.innerHTML = newHtml;
              }
          });
      }
  }

  // Initial fetch when the page loads
  fetchAllDataFromSheets();

  // Poll Google Sheets for updates periodically
  setInterval(fetchAllDataFromSheets, pollingInterval);

</script>
</body>
</html>
)rawliteral";